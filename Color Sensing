#define S0 8
#define S1 9
#define S2 6
#define S3 7
#define sensorOut 2

// If CLEAR pulse gets bigger than this, it's dark/black.
// You MUST tune this after testing black paper/tape.
#define BLACK_CLEAR_PULSE_THRESH 200

// How much better the winning color must be (bigger = stricter)
#define DOMINANCE_RATIO 1.15

unsigned long readPulse(int s2, int s3) {
  digitalWrite(S2, s2);
  digitalWrite(S3, s3);
  delay(5);
  return pulseIn(sensorOut, LOW, 30000);
}

void setup() {
  pinMode(S0, OUTPUT); pinMode(S1, OUTPUT);
  pinMode(S2, OUTPUT); pinMode(S3, OUTPUT);
  pinMode(sensorOut, INPUT);

  // Frequency scaling (common)
  digitalWrite(S0, HIGH);
  digitalWrite(S1, LOW);

  Serial.begin(9600);
}

void loop() {
  // Correct filter modes for YOUR sensor:
  unsigned long pRed   = readPulse(LOW,  LOW);   // 00 = RED
  unsigned long pBlue  = readPulse(LOW,  HIGH);  // 01 = BLUE
  unsigned long pClear = readPulse(HIGH, LOW);   // 10 = CLEAR
  unsigned long pGreen = readPulse(HIGH, HIGH);  // 11 = GREEN

  Serial.print("00(R)="); Serial.print(pRed);
  Serial.print(" 01(B)="); Serial.print(pBlue);
  Serial.print(" 10(CLEAR)="); Serial.print(pClear);
  Serial.print(" 11(G)="); Serial.print(pGreen);
  Serial.print("  -> ");

  // ---- BLACK detection using clear ----
  if (pClear > BLACK_CLEAR_PULSE_THRESH) {
    Serial.println("BLACK");
    delay(300);
    return;
  }

  // Convert pulses to "strength" (smaller pulse => stronger color)
  // strength = 1 / pulse
  float sR = 1.0 / (float)pRed;
  float sG = 1.0 / (float)pGreen;
  float sB = 1.0 / (float)pBlue;

  // Determine dominant color with a little tolerance
  if (sR > sG * DOMINANCE_RATIO && sR > sB * DOMINANCE_RATIO) {
    Serial.println("RED");
  }
  else if (sG > sR * DOMINANCE_RATIO && sG > sB * DOMINANCE_RATIO) {
    Serial.println("GREEN");
  }
  else if (sB > sR * DOMINANCE_RATIO && sB > sG * DOMINANCE_RATIO) {
    Serial.println("BLUE");
  }
  else {
    Serial.println("UNKNOWN / MIXED");
  }

  delay(300);
}
