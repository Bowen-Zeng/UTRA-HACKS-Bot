// GLOBAL VARIABLES ---------------------------------------------
// colors: 0 = not stable, 1 = unknown, 2 = white, 3 = black, 4 = red, 5 = green, 6 = blue
int lastTurnDir = 1;      // 1 = turn right, -1 = turn left
int speedStraight = 120;
int speedFast = 150;
int speedSlow = 60;

// --- PIN DEFINITIONS ---
// Left Motor (A)
const int enA = 3;  // Speed Control
const int in1 = A0;   // Direction
const int in2 = A1;   // Direction

// Right Motor (B)
const int enB = 5;   // Speed Control
const int in3 = A2;   // Direction
const int in4 = A3;   // Direction


// -------- TCS3200 Color Sensor (RGB + BLACK + WHITE) --------
// Uses your confirmed filter mapping:
// 00 (S2 LOW,  S3 LOW)  = RED
// 01 (S2 LOW,  S3 HIGH) = BLUE
// 11 (S2 HIGH, S3 HIGH) = GREEN
// (10 is CLEAR, not needed in this version)

// ---- Pins ----
#define S0 8
#define S1 9
#define S2 6
#define S3 7
#define sensorOut 2

// ---- Tuning knobs (based on your real data) ----
#define CONFIDENCE_RATIO 1.12        // for RGB dominance; raise if mislabels, lower if too many UNKNOWN
#define NEUTRAL_SIMILAR_RATIO 1.30   // higher = easier to call neutral (BLACK/WHITE)
#define BLACK_INTENSITY_MAX 1.50     // only really dim neutrals are BLACK (your black was 0.40–1.17)
#define WHITE_INTENSITY_MIN 2.60     // neutral surfaces brighter than this are WHITE (your “white spots” ~2.90)
#define STABLE_COUNT 3               // must repeat same result this many loops before printing it

// White reference pulses
unsigned long wR, wG, wB;

// Stability filter
int lastCandidate = 0;
int sameCount = 0;

// HELPER FUNCTIONS -----------------------------------------------

void startLeftWheel(int vel) { // -255 - 255
  if (vel < 0) {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    analogWrite(enA, abs(vel));
  } else {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
    analogWrite(enA, abs(vel));
  }
}

void startRightWheel(int vel) { // -255 - 255
  if (vel < 0) {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
    analogWrite(enB, abs(vel));
  } else {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
    analogWrite(enB, abs(vel));
  }
}

void stopLeftWheel() {
  digitalWrite(in1, LOW);
  digitalWrite(in2, LOW);
}

void stopRightWheel() {
  digitalWrite(in3, LOW);
  digitalWrite(in4, LOW);
}

unsigned long readPulse(int s2, int s3) {
  digitalWrite(S2, s2);
  digitalWrite(S3, s3);
  delay(3);
  return pulseIn(sensorOut, LOW, 30000);
}

unsigned long avgPulse(int s2, int s3, int samples = 10) {
  unsigned long sum = 0;
  for (int i = 0; i < samples; i++) {
    unsigned long p = readPulse(s2, s3);
    if (p == 0) p = 30000; // safety
    sum += p;
  }
  return sum / samples;
}

int classify(float sR, float sG, float sB) {
  float intensity = sR + sG + sB;

  float maxS = max(sR, max(sG, sB));
  float minS = min(sR, min(sG, sB));
  bool neutral = (maxS <= minS * NEUTRAL_SIMILAR_RATIO);

  // --- Neutral detection first ---
  if (neutral && intensity <= BLACK_INTENSITY_MAX) return 3;
  if (neutral && intensity >= WHITE_INTENSITY_MIN) return 2;

  // --- RGB dominance ---
  // Find winner and second place
  float max1 = sR, max2 = sG;
  char winner = 'R';

  if (sG > max1) { winner = 'G'; max2 = max1; max1 = sG; }
  else { max2 = sG; }

  if (sB > max1) { winner = 'B'; max2 = max1; max1 = sB; }
  else if (sB > max2) { max2 = sB; }

  // Need a clear gap; otherwise don't guess
  if (max1 < max2 * CONFIDENCE_RATIO) return 1;

  if (winner == 'R') return 4;
  if (winner == 'G') return 5;
  return 6;
}

int getCurrentColor() {
  // Current pulses (averaged)
  unsigned long pR = avgPulse(LOW,  LOW, 10);
  unsigned long pB = avgPulse(LOW,  HIGH, 10);
  unsigned long pG = avgPulse(HIGH, HIGH, 10);

  // Normalize to white: bigger strength = more of that color
  float sR = (float)wR / (float)pR;
  float sG = (float)wG / (float)pG;
  float sB = (float)wB / (float)pB;
  float intensity = sR + sG + sB;

  int candidate = classify(sR, sG, sB);

  // Stability filter (prevents flicker)
  if (candidate == lastCandidate) sameCount++;
  else { lastCandidate = candidate; sameCount = 1; }

  if (sameCount >= STABLE_COUNT) {
    return candidate;
  } else {
    return 0;
  }
}

// Memory-based line following for BLACK line
// targetColor = 3 (black)
void followBlackLine(int currentColor) {
  if (currentColor == 3) {
    // ON BLACK LINE - go straight
    startLeftWheel(speedStraight);
    startRightWheel(speedStraight);
  } 
  else if (currentColor == 2) {
    // ON WHITE - we went too far off, reverse direction
    lastTurnDir = -lastTurnDir;
    if (lastTurnDir == 1) {
      startLeftWheel(speedFast);
      startRightWheel(speedSlow);
    } else {
      startLeftWheel(speedSlow);
      startRightWheel(speedFast);
    }
  } 
  else {
    // UNKNOWN or not stable - keep turning same direction
    if (lastTurnDir == 1) {
      startLeftWheel(speedFast);
      startRightWheel(speedSlow);
    } else {
      startLeftWheel(speedSlow);
      startRightWheel(speedFast);
    }
  }
}


// SETUP ---------------------------------------------------------
void setup() {
  Serial.begin(9600);
  
  // Motor pins
  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);

  // Color sensor pins
  pinMode(S0, OUTPUT); pinMode(S1, OUTPUT);
  pinMode(S2, OUTPUT); pinMode(S3, OUTPUT);
  pinMode(sensorOut, INPUT);

  // Frequency scaling
  digitalWrite(S0, HIGH);
  digitalWrite(S1, LOW);

  // Calibrate on WHITE
  Serial.println("Place WHITE surface under sensor. Calibrating...");
  delay(1000);

  wR = avgPulse(LOW,  LOW);    // RED filter
  wB = avgPulse(LOW,  HIGH);   // BLUE filter
  wG = avgPulse(HIGH, HIGH);   // GREEN filter

  Serial.print("Calibration done. wR="); Serial.print(wR);
  Serial.print(" wG="); Serial.print(wG);
  Serial.print(" wB="); Serial.println(wB);
  Serial.println("Starting line following...");
  delay(500);
}

// MAIN LOOP ------------------------------------------------------
void loop() {
  int currentColor = getCurrentColor();
  Serial.println(currentColor);
  
  // followBlackLine(currentColor);
  
  delay(50);
}

